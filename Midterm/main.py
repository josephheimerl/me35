import json
import serial
import time
import requests
from mysecrets import Broker_IP as broker
from mysecrets import Tufts_Wireless as wifi
from mysecrets import IO_BUTTON_URL as BUTTON_URL, T2_STREAM_URL as T2_URL, T1_STREAM_URL as T1_URL
from mysecrets import headers

# Link to adafruit dashboard: https://io.adafruit.com/jheimerl/dashboards/me-35-midterm

# Change Broker_IP field in mysecrets to the MQTT host IP you want to connect to.

# Add another wifi info field to mysecrets and change wifi import above to connect to 
# desired wifi network

# USB Port to the rp2040 (change based on which port it is connected to)
port = '/dev/tty.usbmodem141101'

def main():
    # Grab data from path json (generated by legPath.py)
    with open('path.json', 'r') as myfile:
        data=myfile.read()
    path = json.loads(data)

    # MQTT server broker topic
    topic_pub = 'angles'

    # generates wifi info string to pass to rp2040
    wifiString = "wifiInfo = {{'ssid':'{ssid}','pass':'{pw}'}}\r\n".format(ssid=wifi['ssid'],pw=wifi['pass'])
    
    with serial.Serial(port, baudrate=115200, timeout=1) as s:
        try:
            CtrlC = '\x03'
            CtrlD = '\x04'
            s.write(CtrlD.encode())
            s.write(b'from rpMQTT import *\r\n')
            s.write(wifiString.encode())
            s.write(("server = rpMQTT('{ip}',wifiInfo,'{topic}')\r\n".format(ip = broker, topic = topic_pub)).encode())
            
            # waits until wifi and mqtt are connected
            checkConnections(s)

            # waits until button is pressed on adafruit.io dashboard
            waitForStart(BUTTON_URL, headers)

            for i in range(len(path["t1"])):
                message = "'({t1},{t2})'".format(t1=path["t1"][i],t2=path["t2"][i])
                s.write(("server.pub({msg})\r\n".format(msg=message)).encode())
                requests.post(T1_URL,headers=headers,data = {'value':path["t1"][i]})
                requests.post(T2_URL,headers=headers,data = {'value':path["t2"][i]})
                time.sleep(0.5)
            
            time.sleep(2)
            s.write(b"server.disconnect()\r\n")

            # wait for a second so disconnect function is able to run
            time.sleep(1)

            
        except KeyboardInterrupt as e:
            # in case of keyboard interrupt before time exception thrown while connecting to wifi,
            # prevents controller from getting stuck in infinite loop trying to connect to wifi
            s.write(CtrlC.encode())
        except Exception as e:
            s.write(CtrlC.encode())
            print(e)
        finally:
            # uncomment next lines to read REPL output after code finishes
            # while True:
            #     data = s.readline().decode()
            #     if not data:
            #         break
            #     print(data)
            exit()



# ensures connections to wifi and MQTT Broker occur, prints out REPL as connections occur
def checkConnections(s):
    CtrlC = '\x03'
    connectedToWifi = False
    startTime = time.time()
    # time allowed to try to connect to wifi or broker before considering it a failure
    connectTime = 10

    while not connectedToWifi:
        text = s.readline().decode()
        if text:
            print(text)
            if "Connection successful" in text:
                connectedToWifi = True
        if time.time() > startTime + connectTime:
            s.write(CtrlC.encode())
            raise Exception("Time to connect to wifi exceeded")

    connectedToBroker = False  
    startTime = time.time()

    while not connectedToBroker:
        text = s.readline().decode()
        if text:
            print(text)
            if "Connected to" in text:
                connectedToBroker = True
            elif "Failed to connect to" in text:
                # sleep prevents light from getting stuck on in this case
                time.sleep(2)
                raise Exception("Failed to connect to MQTT Broker")
        if time.time() > startTime + connectTime:
            s.write(CtrlC.encode())
            raise Exception("Time to connect to MQTT Broker exceeded")

# waits for button to be pressed in adafruit.io dashboard
def waitForStart(BUTTON_URL, headers):
    Start = False
    while not Start:
        try:
            r = requests.get(BUTTON_URL, headers= headers)
            if r.status_code != 200:
                print("failed request: code {code}".format(code=r.status_code))
            else:
                if r.json()['last_value'] == '1':
                    Start = True
            
            # slow to not use up too much of request limit
            time.sleep(2)
        except KeyError as e:
            continue
        except Exception as e:
            print(e)
            exit()

main()